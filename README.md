# Calculadora_assembly
En este repositorio llevamos a cabo la implementación de una calculadora con algunas funciones sencillas, tales como la suma, resta, división y multiplicación con uso de bcd 

# 1. Suma con BCD 
Para realizar la suma con bcd, ocupamos una macro que hace el llenado de ceros en caso de que alguno de los numeros sea menor que el otro, una vez ajustados los dos numeros para que tengan los mismo digitos pasamos a lo  que es la macro que se utilizo,  llamada como BCD_SUM_STRINGS esta macro recibe como parametros los dos numeros y resultado. 
Durante la macro se posiciono los punteros como SI, DI y BX hasta el ultimo digito para realizar la suma de derecha izquierda, se mandejo el uso de la suma con carry en caso de que la suma exediera o fuera mayor a 10, sumando al digito siguiente, se hizo un bucle dentro de cual tambien se hizo el uso de la herramienta AAA la cual es una herramienta que nos sirve para el reajuste, finalmente se hizo el translado a codigo ASCII para su posterior impresion.

![Captura de pantalla 2025-06-19 180110](https://github.com/user-attachments/assets/9b00b340-9e90-4b36-b2dc-6846177d85af)

En la imagen se muestra la funcionalidad de suma donde se ingresan dos números de múltiples dígitos (1267121 + 124121) y el sistema calcula correctamente el resultado (1391242). La interfaz presenta un título "Suma de números" y solicita al usuario ingresar el primer y segundo número, mostrando posteriormente el resultado y preguntando si desea repetir la operación.

# 2. Resta con BCD 
Para llevar a cabo la resta, de igual forma ocupamos la misma macro para hacer el rellenado con ceros, debido a que podemos recibir como parametros un numero mayor que otro en algunos casos, despues del rellenado pasamos a lo que es la resta, donde tambien se hizo un recorrido de los digitos de izquierda a derecha el cual fue implementado en un bucle que retrocediera los puntero SI y DI, ocupamos como herramientas lo que fue el SBB y AAS, donde SBB nos sirvio para el proceso de hacer la resta con carry, mientras que AAS sirvio para el reajuste en binario de nuestra resta, finalmente pasamos de un formato digital a un ASCII el resultaod para la posterior impresion.


![Captura de pantalla 2025-06-19 180325](https://github.com/user-attachments/assets/94949adc-8f1d-41df-bdce-d587c7f83f36)

La imagen demuestra la operación de resta con números de múltiples dígitos (1983241 - 1241), donde el sistema maneja correctamente el préstamo entre dígitos y produce el resultado exacto (1982000). La interfaz mantiene la misma estructura con el título "Resta de números", solicitud de entrada de los operandos, presentación del resultado y opción de repetir la operación.

# 3. Multiplicación con BCD
Para realizar la multiplicación con BCD, se implementó un procedimiento llamado BCD_MUL_PROC que maneja la multiplicación de un número de 4 dígitos por un número de 2 dígitos. El procedimiento recibe tres parámetros principales: el multiplicando en SI, el multiplicador en DI, y el buffer de resultado en BX. Antes de iniciar la multiplicación, se limpia el buffer de resultado llenándolo con el carácter '0' en ASCII y se coloca el terminador '$' al final para asegurar una cadena válida. El proceso de multiplicación se divide en dos etapas principales que corresponden a la multiplicación tradicional en papel, donde se multiplica primero por el dígito de las unidades y luego por el dígito de las decenas del multiplicador. En la primera etapa, se extrae el dígito de las unidades del multiplicador usando MOV AL, [DI+1] y se convierte de ASCII a BCD mediante AND AL, 0FH. Si este dígito es cero, se omite esta etapa y se procede directamente a la multiplicación por las decenas. Para cada dígito del multiplicando, se realiza un recorrido de derecha a izquierda utilizando un contador CX que va de 4 hasta 1. La multiplicación de cada dígito se realiza con la instrucción MUL DL donde DL contiene el multiplicador, seguida inmediatamente de AAM que ajusta el resultado para BCD separando las decenas en AH y las unidades en AL. El resultado de cada multiplicación se suma al valor existente en la posición correspondiente del buffer de resultado, manejando cuidadosamente el acarreo cuando la suma excede 9. Cuando se detecta un acarreo, se resta 10 al dígito actual y se incrementa el dígito de la posición siguiente, propagando el acarreo hacia la izquierda según sea necesario. La segunda etapa procesa el dígito de las decenas del multiplicador de manera similar, pero con un desplazamiento de una posición hacia la izquierda en el buffer de resultado para simular la multiplicación por 10. Este desplazamiento se logra calculando la posición como ADD BX, 5 en lugar de ADD BX, 6, efectivamente colocando los resultados una posición más a la izquierda. El manejo del acarreo en esta etapa es idéntico al de la primera, asegurando que los resultados se propaguen correctamente a través de todas las posiciones. Al finalizar ambas etapas, el buffer de resultado contiene la multiplicación completa en formato ASCII, lista para ser mostrada al usuario.


![Captura de pantalla 2025-06-19 180350](https://github.com/user-attachments/assets/44fd60b4-b631-44a7-8554-289cb0f53734)

La imagen ilustra la operación de multiplicación donde se procesan un número de 4 dígitos (2834) por un número de 2 dígitos (22), generando correctamente el resultado (62348). La interfaz presenta el título "Multiplicación de números" y sigue el mismo patrón de interacción, solicitando ambos operandos, calculando el producto mediante el algoritmo BCD implementado y ofreciendo la opción de repetir la operación.

# 4. División con BCD
Para llevar a cabo la división, se utilizó la macro BCD_DIV_STRINGS que recibe como parámetros el dividendo con un máximo de 5 dígitos, el divisor de un solo dígito, y los buffers para almacenar tanto el resultado como el residuo final. La macro comienza convirtiendo el divisor de formato ASCII a binario mediante SUB BL, '0' y almacenándolo en el registro BL para su uso posterior en las operaciones de división. Se inicializan los punteros SI y DI para apuntar al dividendo y al resultado respectivamente, mientras que el registro DX se limpia para almacenar el resto acumulativo de las divisiones sucesivas. El proceso principal de división se realiza mediante un bucle que recorre cada dígito del dividendo de izquierda a derecha, comenzando por el dígito más significativo. Para cada iteración del bucle, se carga el dígito actual del dividendo en AL y se convierte de ASCII a binario restando '0'. El resto de la división anterior, almacenado en DL, se mueve a AH, y luego se aplica la instrucción AAD que realiza la operación AH x 10 + AL, efectivamente "bajando" el siguiente dígito del dividendo como se hace en la división manual. La división propiamente dicha se ejecuta con DIV BL, donde AL recibe el cociente y AH el nuevo resto. El cociente se convierte inmediatamente a ASCII sumando '0' y se almacena en la posición correspondiente del buffer de resultado, mientras que el resto se guarda en DL para la siguiente iteración. Una característica distintiva de esta implementación es el cálculo automático de decimales una vez que se han procesado todos los dígitos del dividendo. El proceso continúa añadiendo un punto decimal al resultado mediante MOV BYTE PTR [DI], '.' y calculando exactamente dos dígitos decimales adicionales. Para cada dígito decimal, se multiplica el resto actual por 10 colocando 0 en AL y el resto en AH, aplicando AAD para obtener resto x 10, y luego dividiendo nuevamente por el divisor. Este proceso se repite exactamente dos veces usando un contador CX, asegurando una precisión decimal consistente. Al finalizar todo el proceso, el buffer de resultado contiene el cociente completo con punto decimal y dos dígitos de precisión, mientras que el residuo final se almacena por separado en su propio buffer, ambos en formato ASCII listos para su impresión.
![Captura de pantalla 2025-06-19 180412](https://github.com/user-attachments/assets/c0f54477-8404-417a-b74b-9b37b59269dd)


La imagen demuestra la operación de división donde se divide un número de 5 dígitos (23785) entre un dígito (9), produciendo un resultado decimal (02642.77). Esta implementación es particularmente notable porque incluye automáticamente la precisión decimal, mostrando dos dígitos después del punto decimal. La interfaz mantiene la consistencia con las otras operaciones, presentando el título "División de números", solicitando el dividendo y divisor, y mostrando el resultado con

